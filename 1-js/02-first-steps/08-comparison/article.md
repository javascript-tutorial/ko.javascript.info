# 비교

우리는 수학에서 많은 비교 연산자를 배웁니다.

- 보다 큼/작음: <code>a &gt; b</code>, <code>a &lt; b</code>.
- 보다 크거나/작거나 같음: <code>a &gt;= b</code>, <code>a &lt;= b</code>.
- 같음: `a == b` (2개의 `=`기호에 유의합니다. 하나의 기호 `a ​​= b`는 할당을 의미합니다).
- 같지 않음: 수학에서 표기법은 다음과 같습니다. <code>&ne;</code>, 자바스크립트에서는 느낌표가 붙은 할당연산자로 작성됩니다. <code>a != b</code>.

## 결과는 논리 타입(boolean)입니다. 

다른 모든 연산자와 마찬가지로 비교는 값을 반환합니다. 이 경우 값은 불리언 값입니다.

- `true` -- "예", "올바른"또는 "진실"을 의미합니다.
- `false` -- "아니오", "잘못"또는 "진실이 아님"을 의미합니다.

예시:

```js run
alert( 2 > 1 );  // true (correct)
alert( 2 == 1 ); // false (wrong)
alert( 2 != 1 ); // true (correct)
```

비교 결과는 모든 값과 마찬가지로 변수에 할당 할 수 있습니다.

```js run
let result = 5 > 4; // assign the result of the comparison
alert( result ); // true
```

## 문자열 비교

문자열이 다른 문자열보다 큰지 확인하기 위해 자바스크립트는 소위 "사전"(dictionary)또는 "사전 식"(lexicographical)순서를 사용합니다.

즉, 문자열은 문자별로 비교됩니다.

예시:

```js run
alert( 'Z' > 'A' ); // true
alert( 'Glow' > 'Glee' ); // true
alert( 'Bee' > 'Be' ); // true
```

두 문자열을 비교하는 알고리즘은 간단합니다.

1. 두 문자열의 첫 문자를 비교하십시오.
2. 첫번재 문자열의 첫글자가 다른문자열의 첫글자보다 크면(작으면), 첫번째 문자열이 두번째 것보다 큽니다(작습니다.). 끝났습니다. 
3. 그렇지 않으면 두 문자열의 첫 번째 문자가 같은 경우 두 번째 문자를 같은 방식으로 비교합니다.
4. 각 문자열이 끝날 때까지 반복합니다.
5. 두 문자열이 같은 길이로 끝나면 두 문자열은 동일합니다. 그렇지 않으면 긴 문자열이 더 큽니다.

위의 예제에서 문자열 `"Glow"` 와 `"Glee"`가 문자별로 비교되는 동안 비교-`'Z' > 'A'`는 첫 단계에서 결과에 도달합니다.

1. `G`는`G`와 같습니다.
2. `l`은 `l`과 동일합니다.
3. `o`는`e`보다 큽니다. 여기서 멈춥니다. 첫 번째 문자열이 더 큽니다.

```smart header="진짜 사전 순서는 아니지만 유니코드 순서입니다."
위에 주어진 비교 알고리즘은 사전이나 전화번호부에서 사용된 알고리즘과 거의 동일하지만 정확하게 동일하지는 않습니다.

예를 들어, 대소문자가 중요합니다. 대문자 `"A"`는 소문자 `"a"`와 같지 않습니다. 어느 것이 더 큽니까? 소문자 `"a"`입니다. 왜? 소문자는 "자바스크립트가 사용하는 내부 인코딩 테이블"(유니 코드)에서 더 큰 인덱스를 갖기 때문입니다. <info:string> 주제에서 이에 대한 자세한 내용과 결과를 살펴 보겠습니다.
```

## 다른 타입간의 비교

다른 유형의 값을 비교할 때 자바스크립트는 값을 숫자로 변환합니다.

예시:

```js run
alert( '2' > 1 ); // true, string '2' becomes a number 2
alert( '01' == 1 ); // true, string '01' becomes a number 1
```

불리언 값의 경우 `true`는 `1`이되고 `false`는 `0`이됩니다.

예시:

```js run
alert( true == 1 ); // true
alert( false == 0 ); // true
```

````smart header="재미있는 결과"
동시에 다음과 같은 일이 가능합니다:

- 두 값이 같습니다.
- 그 중 하나는 불리언으로 'true'이고 다른 하나는 불리언으로 'false'입니다.

예시:

```js run
let a = 0;
alert( Boolean(a) ); // false

let b = "0";
alert( Boolean(b) ); // true

alert(a == b); // true!
```

자바스크립트의 관점에서 보았을 때, 이 것은 매우 정상적인 결과입니다. 항등 검사`==`는 숫자 변환(`"0"`을 `0`으로)을 사용하여 값을 변환하고, 반면 명시적인 '불리언'변환은 또 다른 규칙을 사용합니다.
````

## 완전 항등 검사

일반적인 항등 검사`==`는 문제가 있습니다. 그것은 `0`과 `false`를 구별할 수 없다는 것입니다ㅣ.

```js run
alert( 0 == false ); // true
```

빈 문자열에서도 같은 일이 발생합니다.

```js run
alert( '' == false ); // true
```

이것은 서로 다른 타입의 피연산자가 항등 연산자`==`에 의해 숫자로 변환되기 때문에 발생합니다. `false`와 마찬가지로 빈 문자열은 0이됩니다.

`0`과 `false`를 구별하려면 어떻게해야 할까요?

**완전 항등 연산자 `===`는 타입 변환없이 항등성을 검사합니다.**

다시 말해, `a`와 `b`가 다른 타입이라면, `a === b`는 변환하려고 시도하지 않고 즉시 `false`를 반환합니다.

해봅시다:

```js run
alert( 0 === false ); // false, because the types are different
```

`!=`와 유사하게 "완전 비항등" 연산자`!==`도 있습니다.

"완전 평등 연산자"는 작성하는 데 약간 시간이 걸리지만, 진행 상황을 명확하게 나타내므로 오류가 발생할 가능성이 적습니다.

## 널(null) 과 정의되지않음(undefined) 의 비교

좀 더 많은 사레를 살펴봅시다.

`null`또는 `undefined`으로 다른 값과 비교할 때 비직관적인 행동을 합니다.


완전 항등 검사`===`
: 이 값들은 각각 다른 유형이기 때문에 서로 다릅니다.

    ```js run
    alert( null === undefined ); // false
    ```

항등 검사`==`
: 특별한 규칙이 있습니다. 이 두 가지는 "달콤한 커플"입니다 : 이 것들은 `==`을 사용하엿을 때 서로 동등하다고 나오지만 어떠한 값도 가지고 있지 않습니다. 

    ```js run
    alert( null == undefined ); // true
    ```

수학과 각각의 비교 `< > <= >=`
: `null/undefined`는 숫자로 변환됩니다. `null`은 `0`이되고 `undefined`는 `NaN`이 됩니다. 

이제 이 규칙을 적용했을 때 일어나는 재미있는 일들을 확인합니다. 그리고 무엇이 더 중요한지, 어떻게 이것들과 함정에 빠지지 않는지 확인합니다.

### 이상한 결과 : null 대 0

`null`과 0을 비교합시다.

```js run
alert( null > 0 );  // (1) false
alert( null == 0 ); // (2) false
alert( null >= 0 ); // (3) *!*true*/!*
```
 
수학적으로 이 결과는 이상합니다. 마지막 결과는 "`null`이 0보다 크거나 같음"을 나타내고, 그래서 마지막 결과 위의 비교 중 하나는 `true`여야 하지만 둘 다 `false`입니다.

그 이유는 항등 검사`==`와 비교`> < >= <=`가 다르게 작동하기 때문입니다. 비교는 `null`을 숫자로 변환하여 `0`으로 처리합니다. 이것이 (3) `null> = 0`이 true이고 (1)`null> 0`이 false 인 이유입니다.

반면, `undefined`와 `null`에 대한 항등 검사`==`는 이렇게 정의됩니다. 어떠한 변환도 없이 이 둘은 서로 같지만 다른 무엇과도 같지않습니다. 이것이 (2)`null == 0`이 거짓인 이유입니다.

### 비교할 수 없는 undefined

`undefined`값은 다른 값과 비교되어서는 안됩니다.

```js run
alert( undefined > 0 ); // false (1)
alert( undefined < 0 ); // false (2)
alert( undefined == 0 ); // false (3)
```

왜 이것은 0을 싫어하나요? 항상 `false` 입니다!

다음과 같은 이유로 이러한 결과를 얻습니다.

- `(1)`과`(2)`는 `undefined`가 `NaN`으로 변환되고 `NaN`이 모든 비교에 대해 `false`를 반환하는 특수한 숫자 값이기 때문입니다. 
- `undefined`는 `null`이나 `undefined`와 같고 이외의 값과는 같지 않기 때문에, 항등검사`(3)`은 `false`를 반환합니다.

### 문제 회피

왜 이 예들을 검토하였을까요? 항상 이러한 특성을 기억해야 할까요? 글쎄요, 그렇진 않습니다. 사실, 이러한 까다로운 일들은 점차 익숙해 질 것입니다. 하지만 문제를 피할 수 있는 견고한 방법이 있습니다.

완전 평등`===`을 제외한 `undefined/null`에 대한 모든 비교를 특별한 주의를 기울여 처리하십시오.

뭘 하고 있는지 확신하지 못한다면, `>= > < <=`비교를 `null/undefined`일 수 있는 변수와 함께 사용하지 마십시오. 변수가 이 값을 가질 수 있으면, 변수를 개별적으로 검사하십시오.

## 요약

- 비교 연산자는 불리언 값을 반환합니다.
- 문자열은 "사전"순서로 문자단위로 비교됩니다.
- 서로 다른 유형의 값을 비교하면 숫자로 변환됩니다 ("완전 항등 검사"는 제외하고).
- `null`값과 `undefined`값은 서로 같고`==` 다른 어떠한 값과도 같지 않습니다.
- 때때로 `null/undefined`일 수 있는 변수에 대해 `>` 또는 `<`같은 비교를 사용할 때 주의하십시오. 개별적으로 `null/undefined`를 체크하는 것은 좋은 생각입니다. 
