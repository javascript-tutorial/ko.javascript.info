개발자는 위와 같이 테스트 코드를 작성하려는 유혹에 빠지곤 합니다.

위 코드엔 세 개의 assert, 즉 세 개의 테스트가 있지만 결론적으로 테스트 함수는 하나뿐입니다.

이렇게 테스트 코드를 작성하면 당장은 쉽게 테스트를 진행할 수 있지만, 에러가 발생했을 때 에러의 원인을 찾기가 힘들어집니다.

실행 흐름이 복잡한 경우 에러가 발생하면 에러를 만든 입력값이 무엇이었는지를 일일이 확인해야 합니다. *테스트 코드를 디버깅* 해야 하는 웃픈 상황이 발생하는 거죠.

테스트는 명확한 입력값, 출력값과 함께 여러 개의 `it` 블록으로 쪼개 작성하는 것이 좋습니다.

아래와 같이 말이죠.
```js
describe("주어진 숫자의 n 제곱", function() {
  it("5를 1 제곱하면 5", function() {
    assert.equal(pow(5, 1), 5);
  });

  it("5를 2 제곱하면 25", function() {
    assert.equal(pow(5, 2), 25);
  });

  it("5를 3 제곱하면 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
```

기존에 하나만 있던 `it` 블록을 여러 개로 쪼개 `describe` 안에 넣어보았습니다. 이렇게 하면 에러가 발생했을 때 입력값이 무엇인지 쉽게 파악할 수 있습니다. 

여기에 더하여 위와 같이 `it` 블록을 여러 개로 쪼개면 `it` 대신 `it.only`를 사용해 원하는 테스트만 실행해 볼 수 있습니다.


```js
describe("주어진 숫자의 n 제곱", function() {
  it("5를 1 제곱하면 5", function() {
    assert.equal(pow(5, 1), 5);
  });

*!*
  // Mocha는 아래 블록만 실행합니다.
  it.only("5를 2 제곱하면 25", function() {
    assert.equal(pow(5, 2), 25);
  });
*/!*

  it("5를 3 제곱하면 125", function() {
    assert.equal(pow(5, 3), 125);
  });
});
```
